<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Shared Expense Tracker (Firebase + Google Login)</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
    h1 { margin: 0 0 12px 0; }
    .topbar { display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:16px; }
    .auth { display:flex; align-items:center; gap:8px; }
    .muted { color:#666; font-size:12px; }
    form { display: flex; gap: 10px; flex-wrap: wrap; margin: 12px 0 20px; }
    input, button { padding: 8px; }
    table { width: 100%; border-collapse: collapse; background: white; }
    th, td { padding: 8px; border: 1px solid #ccc; text-align: left; }
    th { background: #eee; }
    a { color: blue; }
    .hidden { display:none; }
    .thumb { width:48px; height:48px; object-fit:cover; border-radius:6px; border:1px solid #ddd; }
    .error { color:#b00020; font-size:12px; margin:6px 0; }
    .note  { color:#664d03; background:#fff3cd; border:1px solid #ffecb5; padding:6px 8px; border-radius:6px; font-size:12px; }
  </style>

  <!-- Firebase SDKs (compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-storage-compat.js"></script>
</head>
<body>

  <div class="topbar">
    <h1>ðŸ’¸ Shared Expense Tracker</h1>
    <div class="auth">
      <span id="userInfo" class="muted hidden"></span>
      <button id="signInBtn">Sign in with Google</button>
      <button id="signOutBtn" class="hidden">Sign out</button>
    </div>
  </div>

  <div id="authError" class="error"></div>
  <div id="signedOutMsg" class="muted">Please sign in to view and edit shared expenses.</div>

  <div id="app" class="hidden">
    <form id="entryForm">
      <div id="uploadStatus" class="muted"></div>
      <input id="person" name="person" placeholder="Person" required />
      <input id="amount" name="amount" type="number" step="0.01" placeholder="Amount" required />
      <input id="date" name="date" type="date" required />
      <input id="note" name="note" placeholder="Note" />
      <input id="image" name="image" type="file" accept="image/*" />
      <button type="submit">Add</button>
    </form>

    <div id="fallbackNotice" class="note hidden">Network blocked Google Storage. Image was uploaded via Cloudinary instead.</div>

    <table>
      <thead>
        <tr>
          <th>Receipt</th>
          <th>Person</th>
          <th>Amount</th>
          <th>Note</th>
          <th>Date</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>

    <div style="margin-top:10px">
      <button id="resetBtn">Reset All</button>
    </div>
  </div>

<script>
  // === Firebase Config ===
  const firebaseConfig = {
    apiKey: "AIzaSyAPICqhLo25TvAQnCHZiZWDO6qyBA_CLXo",
    authDomain: "sharedexpenses-2510b.firebaseapp.com",
    projectId: "sharedexpenses-2510b",
    storageBucket: "sharedexpenses-2510b.appspot.com",
    messagingSenderId: "312950592413",
    appId: "1:312950592413:web:62239b41780211ba31d574"
  };

  // === Cloudinary (fill these) ===
  const CLOUDINARY_CLOUD  = "YOUR_CLOUD_NAME";     // e.g. "mycloud123"
  const CLOUDINARY_PRESET = "YOUR_UNSIGNED_PRESET"; // e.g. "unsigned_uploads"

  // Init Firebase
  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.firestore();
  const storage = firebase.storage();
  // keep Firebase retries short so we fall back promptly
  storage.setMaxUploadRetryTime(20000);
  storage.setMaxOperationRetryTime(20000);

  const expensesRef = db.collection("expenses");

  // UI refs
  const app = document.getElementById('app');
  const signedOutMsg = document.getElementById('signedOutMsg');
  const userInfo = document.getElementById('userInfo');
  const signInBtn = document.getElementById('signInBtn');
  const signOutBtn = document.getElementById('signOutBtn');
  const authError = document.getElementById('authError');
  const tbody = document.getElementById('tbody');
  const entryForm = document.getElementById('entryForm');
  const resetBtn = document.getElementById('resetBtn');
  const dateInput = document.getElementById('date');
  const uploadStatus = document.getElementById('uploadStatus');
  const fallbackNotice = document.getElementById('fallbackNotice');

  let entries = [];
  let unsubscribe = null;

  function uid(){ return Math.random().toString(36).slice(2) + Date.now().toString(36); }
  function todayStr(){ return new Date().toISOString().slice(0,10); }
  dateInput.value = todayStr();

  // --- Auth
  const provider = new firebase.auth.GoogleAuthProvider();
  async function signInWithGoogle() {
    try { await auth.signInWithPopup(provider); }
    catch (err) { await auth.signInWithRedirect(provider); }
  }
  signInBtn.addEventListener('click', async ()=>{ authError.textContent = ''; try { await signInWithGoogle(); } catch(e){ authError.textContent = 'Sign-in error: ' + (e?.message||e); }});
  signOutBtn.addEventListener('click', async ()=>{ authError.textContent = ''; try { await auth.signOut(); } catch(e){ authError.textContent = 'Sign-out error: ' + (e?.message||e); }});
  auth.getRedirectResult().catch(e=>{ authError.textContent = 'Sign-in error: ' + (e?.message || e); });

  function setFormEnabled(enabled){
    entryForm.querySelectorAll('input,button').forEach(el => el.disabled = !enabled);
  }

  auth.onAuthStateChanged(user=>{
    if(user){
      signInBtn.classList.add('hidden');
      signOutBtn.classList.remove('hidden');
      userInfo.textContent = `Signed in as ${user.displayName || user.email}`;
      userInfo.classList.remove('hidden');
      signedOutMsg.classList.add('hidden');
      app.classList.remove('hidden');
      setFormEnabled(true);

      if (unsubscribe) unsubscribe();
      unsubscribe = expensesRef.orderBy("date","desc").onSnapshot(
        snap=>{ entries = []; snap.forEach(doc => entries.push(doc.data())); render(); },
        err=>{ console.error(err); authError.textContent = 'Read error (Firestore rules/domain?): ' + (err?.message || err); }
      );
    }else{
      if (unsubscribe) unsubscribe();
      entries = []; render();
      userInfo.classList.add('hidden');
      signOutBtn.classList.add('hidden');
      signInBtn.classList.remove('hidden');
      signedOutMsg.classList.remove('hidden');
      app.classList.add('hidden');
      setFormEnabled(false);
    }
  });

  // === Image helpers ===
  async function compressImage(file, maxDim = 1280, quality = 0.8) {
    // Return { blob, contentType }
    return new Promise((resolve) => {
      const originalType = file.type || 'application/octet-stream';
      const reader = new FileReader();
      const img = new Image();
      const fallback = () => resolve({ blob: file, contentType: originalType });

      reader.onerror = fallback; img.onerror = fallback;
      reader.onload = () => { img.src = reader.result; };
      img.onload = () => {
        let { width, height } = img;
        if (width > height && width > maxDim) { height = Math.round(height * (maxDim / width)); width = maxDim; }
        else if (height >= width && height > maxDim) { width = Math.round(width * (maxDim / height)); height = maxDim; }
        const canvas = document.createElement('canvas');
        canvas.width = width; canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        canvas.toBlob((blob) => { if (blob) resolve({ blob, contentType: 'image/jpeg' }); else fallback(); }, 'image/jpeg', quality);
      };
      reader.readAsDataURL(file);
    });
  }

  function toFile(blob, filename, type){
    try { return new File([blob], filename, { type }); }
    catch { return blob; } // older browsers
  }

  async function uploadViaFirebase(blob, filename, contentType){
    const ref = storage.ref(`receipts/${filename}`);
    const metadata = { contentType };
    return new Promise((resolve, reject) => {
      const task = ref.put(blob, metadata);
      task.on('state_changed',
        (snap) => {
          const pct = Math.round((snap.bytesTransferred / snap.totalBytes) * 100);
          uploadStatus.textContent = `Uploadingâ€¦ ${pct}%`;
        },
        reject,
        async () => {
          const url = await ref.getDownloadURL();
          resolve(url);
        }
      );
    });
  }

  async function uploadViaCloudinary(blob, filename, contentType){
    // Needs CLOUDINARY_CLOUD and CLOUDINARY_PRESET filled
    const fileForUpload = toFile(blob, filename, contentType);
    const fd = new FormData();
    fd.append('file', fileForUpload);
    fd.append('upload_preset', CLOUDINARY_PRESET);
    fd.append('folder', 'receipts');

    const endpoint = `https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD}/image/upload`;
    const res = await fetch(endpoint, { method: 'POST', body: fd });
    if(!res.ok){
      const txt = await res.text().catch(()=> '');
      throw new Error('Cloudinary upload failed: ' + (txt||res.statusText));
    }
    const json = await res.json();
    return json.secure_url;
  }

  async function uploadImageSmart(file){
    uploadStatus.textContent = 'Preparing imageâ€¦';

    const { blob, contentType } = await compressImage(file);
    const baseName = (file.name || 'receipt').replace(/[^a-z0-9._-]/gi,'_');
    const filename = `${Date.now()}-${baseName}`.replace(/\.+/g,'.');

    // Try Firebase first
    try {
      const url = await uploadViaFirebase(blob, filename, contentType);
      uploadStatus.textContent = '';
      fallbackNotice.classList.add('hidden');
      return url;
    } catch (e) {
      const msg = (e && e.message) ? e.message : String(e);
      // Timeouts / network blocks â†’ use Cloudinary
      if (msg.includes('retry-limit-exceeded') || msg.toLowerCase().includes('network') || msg.includes('Failed to fetch')) {
        try{
          const url = await uploadViaCloudinary(blob, filename, contentType);
          uploadStatus.textContent = '';
          fallbackNotice.classList.remove('hidden');
          return url;
        }catch (e2){
          uploadStatus.textContent = '';
          throw e2; // show Cloudinary error
        }
      }
      uploadStatus.textContent = '';
      throw e; // other Firebase errors (e.g., rules) surface
    }
  }

  // --- Create entry
  entryForm.addEventListener('submit', async (ev) => {
    ev.preventDefault();
    authError.textContent = '';
    const user = auth.currentUser;
    if(!user){ authError.textContent = 'Please sign in first.'; return; }

    const fd = new FormData(ev.target);
    const person = (fd.get('person')||'').toString().trim();
    const amount = Number(fd.get('amount')||0);
    const note = (fd.get('note')||'').toString();
    const date = (fd.get('date')||todayStr()).toString();

    let imageURL = null;
    const file = fd.get('image');

    const submitBtn = entryForm.querySelector('button[type="submit"]');
    submitBtn.disabled = true;

    try {
      if (file && file.size) {
        imageURL = await uploadImageSmart(file);
      }
      const now = firebase.firestore.FieldValue.serverTimestamp();
      const entry = {
        id: uid(),
        person, amount, note, date, image: imageURL,
        uid: user.uid, email: user.email, displayName: user.displayName || '',
        createdAt: now, updatedAt: now
      };
      await expensesRef.doc(entry.id).set(entry);
      ev.target.reset();
      dateInput.value = todayStr();
      uploadStatus.textContent = '';
      submitBtn.disabled = false;
    } catch (e) {
      console.error(e);
      const msg = e && e.message ? e.message : String(e);
      if (msg.includes('permission') || msg.includes('storage/unauthorized')) {
        authError.textContent = 'Upload blocked by Storage rules. Ensure rules allow request.auth != null and you are signed in.';
      } else {
        authError.textContent = 'Image upload failed: ' + msg;
      }
      uploadStatus.textContent = '';
      submitBtn.disabled = false;
    }
  });

  // --- Delete entry
  tbody.addEventListener('click', async (ev) => {
    const btn = ev.target.closest('button');
    if (!btn) return;
    const id = btn.getAttribute('data-id');
    const action = btn.getAttribute('data-action');
    if (action === 'delete') {
      try {
        if (confirm('Delete this entry?')) await expensesRef.doc(id).delete();
      } catch (e) {
        console.error(e);
        authError.textContent = 'Delete error: ' + (e?.message || e);
      }
    }
  });

  // --- Reset (delete all)
  resetBtn.addEventListener('click', async () => {
    try {
      if (confirm('Clear all entries?')) {
        const snap = await expensesRef.get();
        const batch = db.batch();
        snap.forEach(doc => batch.delete(doc.ref));
        await batch.commit();
      }
    } catch (e) {
      console.error(e);
      authError.textContent = 'Reset error: ' + (e?.message || e);
    }
  });

  // --- Render table
  function render() {
    tbody.innerHTML = entries.map(e => `
      <tr>
        <td>${e.image ? `<a href="${e.image}" target="_blank"><img class="thumb" src="${e.image}" alt="receipt"></a>` : 'â€”'}</td>
        <td>${escapeHtml(e.person)}</td>
        <td>${Number(e.amount||0).toFixed(2)}</td>
        <td>${escapeHtml(e.note||'')}</td>
        <td>${escapeHtml(e.date||'')}</td>
        <td><button data-action="delete" data-id="${e.id}">Delete</button></td>
      </tr>
    `).join('');
  }

  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;","&gt;":"&gt;","\"":"&quot;","'":"&#39;"}[c])); }
</script>
</body>
</html>
