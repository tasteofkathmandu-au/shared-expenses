<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Shared Expense Tracker (Firebase + Google Login)</title>
  <style>
    :root {
      --surface: #ffffff;
      --muted: #666;
      --border: #e5e7eb;
      --header: #f3f4f6;
    }
    body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: var(--surface); color:#111; }
    h1 { margin: 0 0 12px 0; }
    h2 { margin: 20px 0 8px; font-size: 18px; }
    .topbar { display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:16px; }
    .auth { display:flex; align-items:center; gap:8px; }
    .muted { color:var(--muted); font-size:12px; }
    form { display: flex; gap: 10px; flex-wrap: wrap; margin: 12px 0 20px; }
    input, button { padding: 8px; }
    table { width: 100%; border-collapse: collapse; background: white; }
    th, td { padding: 8px; border: 1px solid var(--border); text-align: left; font-size:14px; }
    th { background: var(--header); }
    a { color: blue; }
    .hidden { display:none; }
    .thumb { width:48px; height:48px; object-fit:cover; border-radius:6px; border:1px solid #ddd; }
    .error { color:#b00020; font-size:12px; margin:6px 0; }
    .note  { color:#664d03; background:#fff8db; border:1px solid #ffef9e; padding:6px 8px; border-radius:6px; font-size:12px; }
    .section { margin-top: 18px; }
  </style>

  <!-- Firebase SDKs (compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-storage-compat.js"></script>
</head>
<body>

  <div class="topbar">
    <h1>ðŸ’¸ Shared Expense Tracker</h1>
    <div class="auth">
      <span id="userInfo" class="muted hidden"></span>
      <button id="signInBtn">Sign in with Google</button>
      <button id="signOutBtn" class="hidden">Sign out</button>
    </div>
  </div>

  <div id="authError" class="error"></div>
  <div id="signedOutMsg" class="muted">Please sign in to view and edit shared expenses.</div>

  <div id="app" class="hidden">
    <form id="entryForm">
      <div id="uploadStatus" class="muted"></div>
      <input id="person" name="person" placeholder="Person" required />
      <input id="amount" name="amount" type="number" step="0.01" placeholder="Amount" required />
      <input id="date" name="date" type="date" required />
      <input id="note" name="note" placeholder="Note" />
      <input id="image" name="image" type="file" accept="image/*" />
      <button type="submit">Add</button>
    </form>

    <div id="fallbackNotice" class="note hidden">Network blocked uploads to Firebase Storage. I saved the image inside Firestore instead. Everything will still display normally.</div>

    <div class="section">
      <h2>Expenses</h2>
      <table>
        <thead>
          <tr>
            <th>Receipt</th>
            <th>Person</th>
            <th>Amount</th>
            <th>Note</th>
            <th>Date</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>

    <div class="section">
      <h2>Activity</h2>
      <table>
        <thead>
          <tr>
            <th>When</th>
            <th>Action</th>
          </tr>
        </thead>
        <tbody id="activityTbody"></tbody>
      </table>
    </div>
  </div>

<script>
  // === Your Firebase Config ===
  const firebaseConfig = {
    apiKey: "AIzaSyAPICqhLo25TvAQnCHZiZWDO6qyBA_CLXo",
    authDomain: "sharedexpenses-2510b.firebaseapp.com",
    projectId: "sharedexpenses-2510b",
    storageBucket: "sharedexpenses-2510b.appspot.com",
    messagingSenderId: "312950592413",
    appId: "1:312950592413:web:62239b41780211ba31d574"
  };

  // Init Firebase services
  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.firestore();
  const storage = firebase.storage();
  // keep uploads from hanging forever on shaky networks
  storage.setMaxUploadRetryTime(45000);
  storage.setMaxOperationRetryTime(45000);

  const expensesRef = db.collection("expenses");
  const activityRef = db.collection("activity");

  // UI refs
  const app = document.getElementById('app');
  const signedOutMsg = document.getElementById('signedOutMsg');
  const userInfo = document.getElementById('userInfo');
  const signInBtn = document.getElementById('signInBtn');
  const signOutBtn = document.getElementById('signOutBtn');
  const authError = document.getElementById('authError');
  const tbody = document.getElementById('tbody');
  const entryForm = document.getElementById('entryForm');
  const dateInput = document.getElementById('date');
  const uploadStatus = document.getElementById('uploadStatus');
  const fallbackNotice = document.getElementById('fallbackNotice');
  const activityTbody = document.getElementById('activityTbody');

  let entries = [];
  let activities = [];
  let unsubExpenses = null;
  let unsubActivity = null;

  function uid(){ return Math.random().toString(36).slice(2) + Date.now().toString(36); }
  function todayStr(){ return new Date().toISOString().slice(0,10); }
  dateInput.value = todayStr();

  // --- Auth (popup with redirect fallback)
  const provider = new firebase.auth.GoogleAuthProvider();
  async function signInWithGoogle() {
    try { await auth.signInWithPopup(provider); }
    catch (err) { await auth.signInWithRedirect(provider); }
  }
  signInBtn.addEventListener('click', async ()=>{ authError.textContent = ''; try { await signInWithGoogle(); } catch(e){ authError.textContent = 'Sign-in error: ' + (e?.message||e); }});
  signOutBtn.addEventListener('click', async ()=>{ authError.textContent = ''; try { await auth.signOut(); } catch(e){ authError.textContent = 'Sign-out error: ' + (e?.message||e); }});
  auth.getRedirectResult().catch(e=>{ authError.textContent = 'Sign-in error: ' + (e?.message || e); });

  function setFormEnabled(enabled){
    entryForm.querySelectorAll('input,button').forEach(el => el.disabled = !enabled);
  }

  auth.onAuthStateChanged(user=>{
    if(user){
      signInBtn.classList.add('hidden');
      signOutBtn.classList.remove('hidden');
      userInfo.textContent = `Signed in as ${user.displayName || user.email}`;
      userInfo.classList.remove('hidden');
      signedOutMsg.classList.add('hidden');
      app.classList.remove('hidden');
      setFormEnabled(true);

      if (unsubExpenses) unsubExpenses();
      if (unsubActivity) unsubActivity();
      unsubExpenses = expensesRef.orderBy("date","desc").onSnapshot(
        snap=>{ entries = []; snap.forEach(doc => entries.push(doc.data())); renderExpenses(); },
        err=>{ console.error(err); authError.textContent = 'Read error (Firestore rules/domain?): ' + (err?.message || err); }
      );
      unsubActivity = activityRef.orderBy('when','desc').limit(100).onSnapshot(
        snap=>{ activities = []; snap.forEach(doc => activities.push(doc.data())); renderActivity(); },
        err=>{ console.error(err); authError.textContent = 'Activity read error: ' + (err?.message || err); }
      );
    }else{
      if (unsubExpenses) unsubExpenses();
      if (unsubActivity) unsubActivity();
      entries = []; activities = []; renderExpenses(); renderActivity();
      userInfo.classList.add('hidden');
      signOutBtn.classList.add('hidden');
      signInBtn.classList.remove('hidden');
      signedOutMsg.classList.remove('hidden');
      app.classList.add('hidden');
      setFormEnabled(false);
    }
  });

  // === Image helpers ===
  async function compressImage(file, maxDim = 1280, quality = 0.8) {
    // Return { blob, contentType }
    return new Promise((resolve) => {
      const originalType = file.type || 'application/octet-stream';
      const reader = new FileReader();
      const img = new Image();
      const fallback = () => resolve({ blob: file, contentType: originalType });

      reader.onerror = fallback; img.onerror = fallback;
      reader.onload = () => { img.src = reader.result; };
      img.onload = () => {
        let { width, height } = img;
        if (width > height && width > maxDim) { height = Math.round(height * (maxDim / width)); width = maxDim; }
        else if (height >= width && height > maxDim) { width = Math.round(width * (maxDim / height)); height = maxDim; }
        const canvas = document.createElement('canvas');
        canvas.width = width; canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        canvas.toBlob((blob) => {
          if (blob) resolve({ blob, contentType: 'image/jpeg' });
          else fallback();
        }, 'image/jpeg', quality);
      };
      reader.readAsDataURL(file);
    });
  }

  function blobToDataURL(blob){
    return new Promise((res, rej) => {
      const r = new FileReader();
      r.onerror = rej;
      r.onload = () => res(r.result);
      r.readAsDataURL(blob);
    });
  }

  // Try Storage upload; if network blocks Storage, fall back to inline data URL
  async function uploadImageSmart(file) {
    uploadStatus.textContent = 'Preparing imageâ€¦';

    // compress (or use original) and pick a good contentType
    const { blob, contentType } = await compressImage(file);
    let ext = 'jpg';
    if (contentType !== 'image/jpeg') {
      const m = (file.name || '').match(/\.(\w+)$/); ext = m ? m[1].toLowerCase() : 'bin';
    }
    const baseName = (file.name || 'receipt').replace(/[^a-z0-9._-]/gi,'_');
    const safeName = `${Date.now()}-${baseName}.${ext}`;
    const ref = storage.ref(`receipts/${safeName}`);
    const metadata = { contentType };

    // attempt Storage upload with progress
    try {
      await new Promise((resolve, reject) => {
        const task = ref.put(blob, metadata);
        task.on('state_changed',
          (snap) => {
            const pct = Math.round((snap.bytesTransferred / snap.totalBytes) * 100);
            uploadStatus.textContent = `Uploadingâ€¦ ${pct}%`;
          },
          (err) => reject(err),
          () => resolve()
        );
      });
      const url = await ref.getDownloadURL();
      uploadStatus.textContent = '';
      // normal path
      fallbackNotice.classList.add('hidden');
      return { url, inline: false };
    } catch (err) {
      // If network blocks Storage, use inline data URL so the app still works
      const msg = (err && err.message) ? err.message : String(err);
      if (msg.includes('retry-limit-exceeded') || msg.includes('network') || msg.includes('Failed to fetch')) {
        const dataUrl = await blobToDataURL(blob);
        uploadStatus.textContent = '';
        fallbackNotice.classList.remove('hidden');
        return { url: dataUrl, inline: true };
      }
      uploadStatus.textContent = '';
      throw err; // other errors bubble up (e.g., unauthorized)
    }
  }

  // --- Create entry
  entryForm.addEventListener('submit', async (ev) => {
    ev.preventDefault();
    authError.textContent = '';
    const user = auth.currentUser;
    if(!user){ authError.textContent = 'Please sign in first.'; return; }

    const fd = new FormData(ev.target);
    const person = (fd.get('person')||'').toString().trim();
    const amount = Number(fd.get('amount')||0);
    const note = (fd.get('note')||'').toString();
    const date = (fd.get('date')||todayStr()).toString();

    let imageURL = null;
    const file = fd.get('image');

    const submitBtn = entryForm.querySelector('button[type="submit"]');
    submitBtn.disabled = true;

    try {
      if (file && file.size) {
        const res = await uploadImageSmart(file);  // may fall back to data URL
        imageURL = res.url;
      }

      const now = firebase.firestore.FieldValue.serverTimestamp();
      const entry = {
        id: uid(),
        person, amount, note, date, image: imageURL,
        uid: user.uid, email: user.email, displayName: user.displayName || '',
        createdAt: now, updatedAt: now
      };

      await expensesRef.doc(entry.id).set(entry);

      // Activity log (display only when + action)
      const actionText = `Added ${person ? person + ' â€“ ' : ''}$${Number(amount||0).toFixed(2)}${note ? ' ('+note+')' : ''}`;
      await activityRef.doc(uid()).set({
        action: actionText,
        when: firebase.firestore.FieldValue.serverTimestamp(),
        uid: user.uid,
        email: user.email,
        displayName: user.displayName || ''
      });

      ev.target.reset();
      dateInput.value = todayStr();
      uploadStatus.textContent = '';
      submitBtn.disabled = false;
    } catch (e) {
      console.error(e);
      const msg = e && e.message ? e.message : String(e);
      if (msg.includes('permission') || msg.includes('storage/unauthorized')) {
        authError.textContent = 'Upload blocked by Storage rules. Ensure rules allow request.auth != null and you are signed in.';
      } else if (msg.includes('No default bucket') || msg.includes('storage bucket')) {
        authError.textContent = 'Storage bucket not initialized. Firebase Console â†’ Build â†’ Storage â†’ â€œGet startedâ€.';
      } else {
        authError.textContent = 'Image upload failed: ' + msg;
      }
      uploadStatus.textContent = '';
      submitBtn.disabled = false;
    }
  });

  // --- Delete entry (and log activity)
  tbody.addEventListener('click', async (ev) => {
    const btn = ev.target.closest('button');
    if (!btn) return;
    const id = btn.getAttribute('data-id');
    const action = btn.getAttribute('data-action');
    if (action === 'delete') {
      try {
        if (!confirm('Delete this entry?')) return;
        const user = auth.currentUser;
        const entry = entries.find(x => x.id === id);
        await expensesRef.doc(id).delete();
        // Activity log (display only when + action)
        const actionText = `Deleted ${entry?.person ? entry.person + ' â€“ ' : ''}$${Number(entry?.amount||0).toFixed(2)}${entry?.note ? ' ('+entry.note+')' : ''}`;
        await activityRef.doc(uid()).set({
          action: actionText,
          when: firebase.firestore.FieldValue.serverTimestamp(),
          uid: user?.uid || '',
          email: user?.email || '',
          displayName: user?.displayName || ''
        });
      } catch (e) {
        console.error(e);
        authError.textContent = 'Delete error: ' + (e?.message || e);
      }
    }
  });

  // --- Render expenses
  function renderExpenses() {
    tbody.innerHTML = entries.map(e => `
      <tr>
        <td>${e.image ? `<a href="${e.image}" target="_blank"><img class="thumb" src="${e.image}" alt="receipt"></a>` : 'â€”'}</td>
        <td>${escapeHtml(e.person)}</td>
        <td>${Number(e.amount||0).toFixed(2)}</td>
        <td>${escapeHtml(e.note||'')}</td>
        <td>${escapeHtml(e.date||'')}</td>
        <td><button data-action="delete" data-id="${e.id}">Delete</button></td>
      </tr>
    `).join('');
  }

  // --- Render activity (When + Action only)
  function renderActivity(){
    activityTbody.innerHTML = activities.map(a => `
      <tr>
        <td>${formatWhen(a.when)}</td>
        <td>${escapeHtml(a.action||'')}</td>
      </tr>
    `).join('');
  }

  function formatWhen(ts){
    if (!ts) return '';
    try {
      const d = ts.toDate ? ts.toDate() : new Date(ts);
      return d.toLocaleString();
    } catch { return ''; }
  }

  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;","&gt;":"&gt;","\"":"&quot;","'":"&#39;"}[c])); }
</script>
</body>
</html>
